# Teaching Guide: Rock Paper Scissors Step-by-Step

## How to Use These Prompts

### For Each Step:
1. **Give your student the prompt** - Let them read it and understand the task
2. **Let them implement it** - Don't show them the solution code
3. **Help when stuck** - Use the hints, but encourage them to figure it out
4. **Test together** - Run the code and see if it works
5. **Celebrate success** - Acknowledge their progress before moving on

### Teaching Philosophy:
- **Discovery learning** - They learn by building, not just reading
- **Progressive complexity** - Each step builds on the previous
- **Immediate feedback** - They can test their code right away
- **Ownership** - It's their code, not copied from somewhere

## Step-by-Step Teaching Strategy

### Step 1: Pure Logic (30-45 minutes)
**Goal:** Understand functions and conditional logic
- Let them write the `determineWinner` function
- Test in console to see immediate results
- Ask: "What happens if we change the rules?"

### Step 2: Computer Opponent (30-45 minutes)
**Goal:** Learn arrays, random numbers, function composition
- They'll discover how to generate random choices
- Test multiple games to see randomness
- Ask: "How could we make the computer smarter?"

### Step 3: First React Component (45-60 minutes)
**Goal:** Introduction to React, state, and UI
- This is a big step - be patient
- Explain `useState` carefully
- Ask: "What happens when we click a button?"

### Step 4: More State (30-45 minutes)
**Goal:** Multiple state variables and conditional rendering
- They'll see how state connects to UI
- Ask: "Why do we need to remember what each player chose?"

### Step 5: Scoring (30-45 minutes)
**Goal:** State updates and persistence
- They'll understand how state persists between interactions
- Ask: "How could we save the high score?"

### Step 6: Reset and Refactoring (30-45 minutes)
**Goal:** Code organization and user experience
- They'll learn about code improvement
- Ask: "What other features could we add?"

### Final Step: Polish (30-45 minutes)
**Goal:** TypeScript and production considerations
- They'll see how types prevent errors
- Ask: "What makes this code production-ready?"

## Key Questions to Ask Throughout:

### Conceptual Questions:
- "What do you think this code does?"
- "How could we test this?"
- "What happens if we change this part?"

### Problem-Solving Questions:
- "What's not working? Let's debug together."
- "What error message are you seeing?"
- "How could we fix this?"

### Extension Questions:
- "What if we wanted to add [feature]?"
- "How could we make this more fun?"
- "What would make this better?"

## Common Challenges and Solutions:

### "I don't know where to start"
- Break it down: "Let's just write the function signature first"
- Start simple: "What's the easiest part to test?"

### "It's not working"
- Debug together: "What do you expect to happen?"
- Check console: "Are there any error messages?"
- Test step by step: "Let's test just this part"

### "I'm stuck"
- Use hints: "Look at the hints section"
- Simplify: "Let's make it work with just one case first"
- Encourage: "You're close! Let's figure out this last part"

## Success Indicators:

### They're Learning When:
- They can explain what their code does
- They can debug their own errors
- They ask "what if" questions
- They want to add their own features

### Red Flags:
- They're copying without understanding
- They're frustrated and not making progress
- They can't explain their code
- They're not testing their work

## After Completion:

### Celebrate Their Achievement:
- "You built a complete game from scratch!"
- "You learned React, TypeScript, and state management!"
- "You can now build other interactive apps!"

### Next Steps:
- Deploy the game to the web
- Add CSS styling
- Build another game (Tic-tac-toe, Memory, etc.)
- Learn about APIs and data

## Remember:
- **Patience** - Everyone learns at their own pace
- **Encouragement** - Celebrate small wins
- **Curiosity** - Ask questions that make them think
- **Ownership** - It's their project, not yours
- **Fun** - Keep it enjoyable and engaging

This approach teaches not just coding, but problem-solving, debugging, and the joy of building something that works! 